\chapter{Exercise 31: Debugging Code}

我们已经学习过如何使用超强悍 debug macros。当我们调试代码的时候专门使用
\ident{debug()}宏来跟踪代码出错的地方。这一章节，我们将会学习到一些基
本的 gdb 调试命令，用它来调试一个无法正常退出的程序。而且，您将会掌握如何使
用 gdb 去调试一个已经运行的进程。最后，我会传授您一些如何更好使用 gdb 的
技巧。

\section{Debug Printing Vs. GDB Vs. Valgrind}

我们将用科学的方法去探讨如何调试代码。我们尽可能想出出错原因，排除它
或者证明是什么引起错误。很多程序员都有过这样的想法，担心代码出错或者急于找
到代码中的错误会“影响开发进度”。如果急忙去排错，只会被收集到的错误信息耍得团团转。
我们有更科学的方法解决错误--记录日志（打印调试信息），这样收集来的信息
更科学更简单。

除此之外，还有以下几点原因把打印调试信息做为我的首要调试方法。
\begin{enumerate}
\item You see an entire tracing of a program's execution with debug printing of variables which lets you
    track how things are going wrong.  With gdb you have to place watch and debug statements all over
    for every thing you want and it's difficult to get a solid trace of the execution.
\item The debug prints can stay in the code, and when you need them you can recompile and they come back.
    With gdb you have to configure the same information uniquely for every defect you have to hunt down.
\item It's easier to turn on debug logging on a server that's not working right and then inspect the logs while
    it runs to see what's going on.  System administrators know how to handle logging, they don't know how
    to use gdb.
\item Printing things is just easier. Debuggers are always obtuse and weird with their own quirky interface and
    inconsistencies.  There's nothing complicated about \verb|debug("Yo, dis right? %d", my_stuff);|.
\item Writing debug prints to find a defect forces you to actually analyze the code and use the scientific method.
    You can think of a debug usage as, "I hypothesize that the code is broken here."  Then when you run it
    you get your hypothesis tested and if it's not broken then you can move to another part where it could be.
    This may seem like it takes longer, but it's actually faster because you go through a process of "differential
    diagnosis" and rule out possible causes until you find the real one.
\item Debug printing works better with unit testing.  You can actually just compile the debugs in all the time
    while you work, and when a unit test explodes just go look at the logs any time.  With gdb you'd have to
    rerun the unit test under gdb and then trace through it to see what's going on.
\item With valgrind you get the equivalent of debug prints for many memory related errors, so you don't need to
    use something like gdb to find those defects anymore.
\end{enumerate}

\begin{enumerate}
\item 打印调试信息在整个程序运行中可以让您发现变量运行到哪一步出错。如
  果使用 gdb 你需要给变量设观察点（watch）调试所有有关语句，想很好定位出
  错地方是很困难的。
\item 打印调试信息可以保留在代码里。在需要时把他们编译出来就行了。
  如果使用 gdb 你需要给相同的信息使用不同设置，直到把问题一个一个找出
  来。
\item 程序在一台服务器中运行异常，我们可以简单开启打印调试信息功能查看发生
  了什么情况。系统管理员更喜欢去分析日志，而不是使用 gdb 排错。
\item 打印信息很简单。调试器古怪的界面总会与它给出的信息不太协调。还不
  如来一句 \verb|debug("Yo, dis right? %d", my_stuff)| 简单明了。
\item 打印调试信息会迫使你使用合理的方法去分析代码中的错误。我们可以这
  样设想：“肯定是这段代码出了问题”。然后我们去调试这段可能出错的代码，
  如果不是这个地方出错，那我们可以把这个地方排除掉，去找下一个目标。这可
  能要花上一些时间，但这确实很快了。我们是在给出错的程序做“鉴别诊断”，
  直到找出真正的病因。
\item 打印调试信息比单元测试效果好此。

\end{enumerater}


Despite all these reasons that I rely on \ident{debug} over \program{gdb}, I
still use \program{gdb} in a few situations and I think you should have any
tool that helps you get your work done.  Sometimes, you just have to connect to
a broken program and poke around.  Or, maybe you've got a server that's
crashing and you can only get at core files to see why.  In these and a few
other cases, gdb is the way to go, and it's always good to have as many tools
as possible to help solve problems.

我一般在这样的情况下使用 gdb、Valgrind、打印调试作息：

\begin{enumerate}
\item Valgrind 是用来捕捉内存错误。如果 Valgrind 无法解决问题或者影响
  了程序性能，就把它换成 gdb。
\item 打印调试信息可以用来诊断或者修复一些逻辑问题。在使用 Valgrind 之
  前九成左右的问题都可以用它来解决。
\item gdb 主要用来对付那“古怪难缠”或者紧急的问题。如果 Valgrind 无法发
  现问题甚至打印调试信息也对我没有帮助，我将要借助 gdb 去探探究竟了。
  gdb 在下面的例子中主要收集信息。当我想到问题出错在哪，我会写一个单
  元测试去重现问题。把程序的运行状态记录下来，找到问题所在。
\end{enumerate}

\section{A Debugging Strategy}

这样的技术操作流程可以用在很多测试场合。无论是 Valgrind、打印测试信息、
还是使用调试器。我们将使用 \program{gdb} 来介绍这样的测试流程，很多人都忽
略这样的测试方法。这个方法适用在所有错误问题上，就算是一个非常难缠的问题。

\begin{enumerate}
\item 新建一个文件名为 \file{notes.txt}。就像做“实验记录”一样写下想
  法、错误、问题等等。
\item 使用 \program{gdb} 之前，你应该记录下怎么去改掉错误，错误是由什
  么引起的。
\item 每一个问题中，都应该记录下文件名和相关函数，他们为什么会在这出现。
  或者记录一些你不太清楚的事情。
\item 现在可以启动 \program{gdb} 了，在第一个假设的问题那设置个断点。
  用刚刚记录的文件名和相关函数(file:function)。
\item 执行 \program{gdb} 到相关的断点。最好使用 \ident{set} 命令修改变量,尝试
  修复问题，或者立即重现错误。
\item 如果问题不在这里, 写上原因把它记录到 \file{notes.txt} 文件中。然
  后跳到下个假设的问题。保持这样的调试方法，把所有可能的信息收集起来。
\end{enumerate}


现在你已经知道，怎么科学使用这些基本方法。写下假设出错的地方，设法证明这
段代码是正确的或者是错误的。写下来，能让你更加深刻了解可能出错的地方，
直到最后解决问题。这样的流程能避免重蹈覆辙，把错误当成正解去处理。

打印调试作息当然也可以一同使用。有点小区别，就是把假设的问题从
\file{notes.txt} 移到可能出错的代码上。在某种意义上，假设写入打印调试
信息中可迫使你更系统的去找出错误。


\section{Using GDB}

接下来我们要调试一个无法正确终止的 while 语句。while 语句中加入了
\ident{usleep} 函数，这样调试起来更加方便。

\begin{code}{ex31.c}
<< d['code/ex31.c|pyg|l'] >>
\end{code}

正常编译它，然后使用 \program{gdb} 启动。像这样：\verb|gdb ./ex31|

调试开始时，我们将用到下列 \program{gdb} 命令。

\begin{description}
\item[help COMMAND] 显示命令使用方法。
\item[break file.c(行号|函数名)] 给程序需要暂停的地方设置一个断点。你
  可以行号或者函数名设置一个断点。
\item[run 参数] 运行程序。run 后面加上参数可以把参数传递给调试的程序。
\item[cont] 让程序一直运行，直到遇到断点或错误。
\item[step] 程序执行下一步。但是 \emph{进入函数内部}。用他可查看函数内
  部动作状况。
\item[next] 与 \ident{step} 功能差不多。但是 \emph{跳过当前函数}，直接使用
  函数。
\item[backtrace (bt)] 显示栈帧，查看函数在程序中运行的地址。可以查看停
  留在程序的什么地方，同样可以列出传给函数的参数。与 Valgrind 内存错误
  报告差不多。
\item[set var X = Y] 重新赋值 X 变量为 Y 。
\item[print X] 打印 X 变量的值。就像正常使用C语言语法一样，对变量的指
  针或者结构体取值。
\item[ENTER] 重复上一次命令。
\item[quit] 退出 \program{gdb}。
\end{description}


这些命令我们将会在 \program{gdb} 中经常用到。现在，你的任务就是在
\program{ex31} 调试中熟练使用这些命令。


一旦你熟练使用 \program{gdb}，就会想在更多的地方使用它。尝试去调试其他
程序，如 \program{devpkg}。如果能修改它，或者分析它是如何工作的那就更
好了。

\section{Process Attaching}

\program{gdb} 还有个强大的功能，那就是调试正在运行中的进程。有些进程或
者图形界面程序出错了，但并没完全退出。想使用 \program{gdb} 启动程序重
现错误，恐怕有点难。当运行的程序没有完全崩溃，我们可以启动
\program{gdb} attach 到出错的进程并设置断点。接下来的练习我们将学习到这
种方法。

现在我们重新启动那个死循环的程序 \program{ex31}。再打开另一个终端，
以便使用 \program{gdb} 调试它。attach 一个进程，就是让 \program{gdb}
去与被调试的进程作连接，查看进程的运行状态。attach 可以暂停进程，以便
控制它的运行。当你检查完错误后，退出 \program{gdb} 进程还可以正常运行。

下面我们将使用 \program{ex31} 做例子。修复这个死循环，让程序可以退出。
\begin{code}{ex31.sh-session}
<< d['code/ex31.sh-session|pyg|l'] >>
\end{code}

\begin{aside}{OSX Problems}
在苹果操作系统中调试，可能会弹出一个需要输入管理员密码的对话框。输入完
密码后， \program{gdb} 会得到这样的提示: “Unable to access task for
process-id XXX (os/kern) failure.”。那样的话，\program{gdb} 和
\program{ex31} 都会被中止。请再重新启动程序，再次输入管理员密码就会成
功的。
\end{aside}

接下来释我们是如何工作的：

\begin{description}
\item[gdb:1] 执行 \program{ps} 命令找到 \program{ex31} 进程的 ID 号。
\item[gdb:5] 使用刚得到的进程 ID 号替换 \verb|gdb ./ex31 PID| 的 PID。
\item[gdb:6-19] 一些关于 \program{gdb} 版本和版权之类的信息。
\item[gdb:21] 我们连接进程时，它正好运行到这个地方。我们用
  \ident{break} 在代码第8行设置一个断点。现在断点已经设置好了，只要我
  们愿意就可以再次中断它。
\item[gdb:24] 一个好的\ident{断点}设置方法 \file{file.c:line}。这样可
  保证你的断点设置在正解的地方。我就是这样做的。
\item[gdb:27] 我们使用 \ident{cont} 命令。让进程一直运行，直到遇到断点
  停下来。
\item[gdb:33-31] 断点停下来的地方打印出当前函数的一些信息(\ident{argc}
  和 \ident{argv})。还有与断点有关的代码。
\item[gdb:33-34] 我们使用 \ident{print} "p" 打印出变量 i 的值，它为0。
\item[gdb:36] 继续运行看看变量 \ident{i} 有什么变化。
\item[gdb:42] 结果变量 \ident{i} 还是没有变化。
\item[gdb:45-55] 使用 \ident{list} 查看下代码。结果很明显，代码中没有
  找到对变量 \ident{i} 作处理的语句，程序当然无法退出。
\item[gdb:57] 假设我们使用 \ident{set} 命令改变 \ident{i} 的值为
  \verb|i = 200|。如果这个方法可行，我们可以很快看到结果，快速地修复了
  一个错误。
\item[gdb:59] 再次打印 \ident{i} 的值，确认它已经改变。
\item[gdb:62] 使用 \ident{next} 单步运行程序。我们可以看到程序运程到
  \file{ex31.c:12} 停了下来。意味着循环退出,我们的假设是正确的。我们改
  变了 \indent{i} 的值。
\item[gdb:67] 使用\ident{cont} 让程序正常退出。
\item[gdb:71] 最后我们使用 \ident{quit} 退出 \program{gdb}。
\end{description}




\section{GDB Tricks}

这里有一些在 gdb 调试时可以使用的小技巧。

\begin{description}
\item[gdb --args] 通常情況下，启动带参数的 \program{gdb} 会把所有的参数当成
  自己的。我们只需在 gdb 后面加上 \program{--args} 就可以把参数
  传给要调试的程序。(如:gdb --args ex31 ``hello world'')
\item[thread apply all bt] 多线程调试时，使用 backtrace 可以显示
  \emph{所有}线程栈帧信息。很有用。
\item[gdb --batch --ex r --ex bt --ex q --args] 如果运行一个程序异常退
  出，用这个方法可以很快定位出错地方。并显示栈帧信息。
\item[?] (待译)
\end{description}

\section{Extra Credit}

\begin{enumerate}
\item 找个图形界面的调试器与命令行的 \program{gdb} 作比较，熟练使用他
  们。当远程调试服务器上的程序时，图形界面的调试器看起来更加本地化，更
  容易上手。
\item 启用系统中的 “内核转储(core dump)”\footnote{译注：大多数 linux
    发行版本默认情况下关闭了内核转储功能。用 ulimit -c 命令可以查看当前的内核转储
    功能是否有效。如 ulimit -c 1073741824 可以限制内核转储大小为 1GB。}。
  程序崩溃时可以得到一个内核转储文件。调试时加载此文件，可以看到程序
  崩溃前运行状态，是什么引起程序崩溃，就如同给程序验尸一样。尝试修改
  \file{ex31.c} 文件的代码，让它迭代至崩溃。然后分析下得到的内核转储文
  件。
\end{enumerate}